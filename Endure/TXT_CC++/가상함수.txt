Q. 가상함수에 대해 설명하시오 

Q. 가상함수 테이블이란 무엇인가

Q. 추상클래스의 포인터 변수 선언이 가능한가?

Q. 다중상속에서 가상함수 테이블이란

Q. vtable 의 크기와 생성시점, 성능에 대해 설명하시오 

Q. 가상소멸자에 대해 설명하시오 

Q. 소멸자에서 다른 가상 함수를 호출할 때 주의사항

----------------------------------------------
Q. 가상함수에 대해 설명하시오 
A.	정의 
	부모 클래스에서 선언되고, 자식 클래스에서 재정의(Override)될 수 있는 함수로, 런타임에 객체의 실제 타입에 따라 호출할 함수를 동적으로 결정합니다.
	virtual 키워드를 사용하여 선언하며, 동적 바인딩을 지원합니다.

	왜 사용하는가?
		1. 다형성 구현 : 하나의 인터페이스로 다양한 객체를 처리할 수 있다. 
		2. 코드 확장성 : 새로운 자식클래스를 추가하거나 동작을 수정할 때 부모클래스의 코드를 변경하지 않아도 된다. 
		3. 런타임 동작 제어 : 런타임에 객체의 타입에 따라 적절한 함수를 호출할 수 있다. 

	작동원리 
		가상 함수는 가상 함수 테이블(Virtual Table, Vtable)과 가상 테이블 포인터(VPTR)를 통해 동작합니다.
		클래스 생성 시 : 클래스에 가상 함수가 포함되면, 컴파일러는 해당 클래스에 대한 Vtable을 생성합니다.
		객체 생성 시 : 객체는 VPTR을 포함하며, 이는 객체가 속한 클래스의 Vtable을 가리킵니다.
		함수 호출 시 : VPTR을 통해 Vtable에 접근하고, 해당 함수의 주소를 확인하여 적절한 함수를 호출합니다.

	예시
		Animal* animal1 = new Dog();
		Animal* animal2 = new Cat();

		animal1->sound(); // Bark
		animal2->sound(); // Meow
		
----------------------------------------------

Q.	가상함수 테이블이란 무엇인가
A.	클래스에 가상 함수(virtual)가 포함된 경우, 컴파일러가 생성하며, 가상 함수의 주소를 저장하는 테이블입니다.
	
	Vtable 특징
	1) 클래스 단위로 생성 : 각 클래스에 대해 하나의 Vtable이 생성됩니다. 클래스의 모든 객체는 같은 Vtable을 공유합니다.
	2) 가상 함수만 포함 : Vtable에는 가상 함수(virtual)만 포함됩니다.
		비가상 함수는 정적 바인딩(Static Binding)으로 처리되므로 Vtable과 무관합니다.
	3) 재정의된 함수로 대체 : 자식 클래스에서 가상 함수를 재정의하면, 부모 클래스의 해당 가상 함수 포인터가 자식 클래스의 함수로 대체됩니다.
	4) Vtable은 컴파일러가 관리 : Vtable과 VPTR의 생성 및 관리는 컴파일러에 의해 자동으로 처리됩니다.

	장점
		다형성 지원: 부모 포인터를 통해 자식 클래스의 재정의된 함수를 호출할 수 있습니다.
		유연성: 런타임에 객체 타입에 따라 동작을 변경할 수 있습니다.
	단점
		성능 오버헤드: VPTR과 Vtable을 사용한 간접 호출로 인해 정적 바인딩보다 약간 느립니다.
		메모리 오버헤드: Vtable과 VPTR로 인해 약간의 추가 메모리가 필요합니다.
		구조 복잡성: 다중 상속과 함께 사용될 경우, Vtable 관리가 복잡해질 수 있습니다.
		
-------------------------------------------------------
	
Q. 추상클래스의 포인터 변수 선언이 가능한가? (CAnimal* pAnim;)
A. 가능합니다.
	해당 코드는 메모리에 할당된 객체가 아니라 포인터 변수를 선언하는 과정이기때문에 추상 클래스여도 문제가 되지 않습니다. 
	다만, Shape shape; // 오류: 추상 클래스의 객체 생성 불가
	
-------------------------------------------------------

Q. 다중상속에서 가상함수 테이블이란
A.	단일상속 : VPTR은 하나만 존재하며, 객체는 자신이 속한 클래스의 Vtable을 가리킵니다.
		-> 자식클래스에서 부모 클래스의 가상 함수 주소가 포함됩니다.
		= 단일 상속에서는 함수 이름 충돌이 발생하지 않으므로, 부모 VPTR이 따로 필요하지 않습니다.
	다중상속 : 모 클래스에서 같은 이름의 함수가 존재할 가능성이 있어서 부모 클래스마다의 독립적인 VPTR을 가집니다. 
		-> 본인 제외 부모의 수만큼의 VPTR를 갖는다. 

	+Q. 그렇다면 재정의될경우 ?
		자식클래스에서 부모클래스의 가상함수를 재정의할경우 부모클래스의 Vtable에는 해당 함수 항목이 자식클래스의 함수로 업데이트된다. 
-------------------------------------------------------

Q. vtable 의 크기와 생성시점, 성능에 대해 설명하시오 
A.	가상함수 포인터마다 4바이트의 크기를 갖고 있다. 
	객체마다 가상함수 포인터를 가지고 있어 오버헤드가 발생할 수 있으나 동적 바인딩을 통해 다형성을 사용해야 하는 경우 성능상의 이점이 많아 사용할 수 있다.
	
-------------------------------------------------------
	
Q.	가상소멸자에 대해 설명하시오 
A.	정의 : 부모 클래스 포인터를 통해 자식 클래스 객체를 삭제할 때, 자식 클래스의 소멸자가 먼저 호출되도록 보장합니다.

	왜 사용하는가 ?
		1. 동적 메모리 해제에서 자식 클래스의 소멸자 호출 보장
			가상 소멸자를 사용하지 않으면 자식 클래스의 소멸자가 호출되지 않기때문에 자식 클래스에서 할당한 리소스가 해제되지 않아 메모리 누수가 발생할 수 있습니다.

	동작 원리
		1) 가상 함수 테이블(Vtable) 활용
			가상 소멸자도 다른 가상 함수처럼 Vtable에 등록됩니다.
			객체 삭제 시 VPTR을 통해 Vtable에서 소멸자의 주소를 조회하고, 자식 클래스의 소멸자가 먼저 호출됩니다.
		2) 호출 순서
			자식 클래스의 소멸자가 호출됨.
			부모 클래스의 소멸자가 호출됨.

----------------------------------------------

Q.	소멸자에서 다른 가상 함수를 호출할 때 주의사항
A.	소멸자는 자식 클래스 → 부모 클래스 순서로 호출됩니다.
	따라서, 자식 클래스의 소멸자가 실행될 때는 정상적으로 동작하지만, 부모 클래스의 소멸자가 실행 중일 때 자식 클래스의 가상 함수는 호출되지 않습니다.
	왜냐하면 소멸자 실행 시, 해당 클래스의 가상 함수 테이블(Vtable)은 현재 클래스 수준으로 축소됩니다.
	이게 무슨말이냐면, 
		부모 클래스의 소멸자에서 가상 함수를 호출하면, 현재 Vtable이 부모 클래스의 수준으로 설정되므로, 자식 클래스에서 재정의된 함수는 호출되지 않습니다.