Q. c++ 11에서 이동이란 개념이 STL 컨테이너에 미치는 영향은 무엇이며 이를 통해 얻을 수 있는 성능의 이점은 무엇인가?

Q. move와 forward의 차이점은 무엇이고, STL과 함께 사용할 때 각각 어떤 역할을 하는가?

Q. 범위기반 for문은 STL 컨테이너와 함께 어떻게 활용되며, 기존의 반복자(iterator) 루프와 비교했을 때 어떤 장점이 있는가?

----------------------- 

A. (2024. 11. 21)
	이동개념 즉 Move Semantics은 복사하는 대신 소유권을 이동하는 방식으로 데이터 전송을 최적화 하는 기법입니다. 
	
	vector의경우 push_back에서 기존 배열의 크기가 부족한경우 이동생성자를 통해 기존값의 복사본이 아닌 소유권을 이동하는 방식으로 비용이 줄어들고 
	리스트나 맵같은경우도 원소를 삽입할 때 복사본을 만들지 않고 소유권을 다른 객체로 이동시키는 방식으로 삽입하게됩니다. 

	이렇게 객체간의 자원의 소유권을 이동시키면서 메모리 할당을 최소화 하고 복사비용이 줄어들어 성능이 향상됩니다. 
	특히 대용량 데이터를 처리할경우에 큰 성능향상을 제공합니다. 

	
A. (2024. 11. 21)
	move와 foward는 각각 이동과 전달이라는 의미를 가진 함수입니다. 
	함수의 결과는 이동이나 전달일 수 있지만 실제로 수행하는것은 캐스팅인데, 
	
	move의경우 이동 하는것만이 아니라 이동연산자를 호출하여 rvalue로 캐스팅하는 역할을 하여 객체를 이동가능하게 만들어서 다른객체로 소유권을 이동시킬 수 있게합니다. 
	예를들어, 벡터의 push_back에서 기존 배열의 크기가 부족한경우한 원소추가시 복사가 되지않고 이동하는 방식으로 사용하며

	rvalue를 전달할 때 move가 발생하고, lvalue를 전달할 때 복사가 발생하여 성능을 최적화할 수 있습니다. 
	특히 emplace나 insert와 같은 함수에서 이를 사용하면, 객체의 복사/이동을 적절히 처리하여 효율성을 높일 수 있습니다.

	[stl 아닌 예시]
	forward는 원본값의 특성을 그대로 전달하는것입니다. r-value는 r-value값으로 전달하고, l-value는 l-value의 값으로 전달하게됩니다. 
	만약에 l-value와 r-value로 전달된 매개변수에 따라 다르게 동작하는 오버라이드 함수가 있다고 했을때, 
	forward를 사용하지 않으면 rvalue도 lvalue로 잘못 전달될 수 있어 성능최적화가 제대로 이루어지지 않게됩니다. 



A. (2024. 11. 21)
	범위기반 for문은 벡터, 리스트, 맵 등과 같은 stl컨테이너에서 반복을 수행할 때 사용됩니다. 
	기존의 반복자는 begin과 end를 사용하여 첫번째와 마지막 요소를 iterator를 통해 접근하고 반복자의 증가를 수동으로 관리해야합니다. 
	이경우 코드가 복잡해질수있다는 단점이 있습니다. 
	반면 범위기반 for문의경우 내부적으로 begin과 end를 호출하여 자동으로 모든 요소에 대해 반복을 수행하게됩니다. 따라서 오버플로우와 같은 실수를 방지할수 있다는 장점이 있습니다. 
	또한 참조를 통해 원소를 받을경우 주소를 넘기는것이기때문에 용량이 큰 컨테이너나 사용자정의타입에 효과적으로 사용할 수 있습니다.


A. (2024. 11. 21)




A. (2024. 11. 21)