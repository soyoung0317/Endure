Q. new 와 malloc에 대해 설명하시오 

Q. 아래와 같은 상황에서 어디에서 오류가 발생하는가? 왜 그런지 설명하시오 
	1 : int* pa = new int;
	2 : delete pa;
	3 : delete pa;
	4 : pa = nullptr;
	5 : pa = new int;
	6 : int doit = 2;
	7 : int* pb = &doit;
	8 : delete pb;

Q. malloc과 new 언제 사용하는가?

Q. calloc, malloc, realloc, new의 차이점에 대해 설명하시오 

Q. 메모리 할당이 제대로 되지 못한 상황에서 new의 동작반응에 대해 설명하시오 

-------------------------------------------------

Q. new 와 malloc에 대해 설명하시오 
A.	new
	정의 : 객체 생성 시 생성자 호출과 함께 메모리를 할당하며, 자동으로 타입을 결정.
	기능 : 객체 생성 + 동적 메모리 할당	
	타입 : 	반환값이 지정된 타입	
	생성자 호출 : 생성자 호출	
	메모리 해제 : delete 연산자로 해제	
	안전성 : 타입 안전	
	크기 명시 : 명시 필요 없음	
	예외 처리 : 메모리 부족 시 예외(std::bad_alloc) 발생	

	malloc
	정의 : 객체 생성 시 생성자 호출과 함께 메모리를 할당하며, 자동으로 타입을 결정.
	기능 : 동적 메모리 할당만 수행
	타입 : 반환값이 void* 타입 (캐스팅 필요)
	생성자 호출 : 생성자 호출 불가
	메모리 해제 : free() 함수로 해제
	안전성 : 타입 안전하지 않음
	크기 명시 : 명시적으로 크기를 전달해야 함	
	예외 처리 : 메모리 부족 시 NULL 반환

	MyClass* obj = (MyClass*)malloc(sizeof(MyClass));
	int* ptr = (int*)malloc(sizeof(int));


	malloc은 C에서 사용되는 동적할당 키워드로 생성자가 없어서 동적할당을 할 때 쓰레기값이 들어가게됩니다. 
	반면 new는 c++에서 사용하는 동적할당 키워드로 생성자를 통해 동적할당되기때문에 프로그래머가 임의적으로 초기화를 진행할 수 있습니다. 
	
-------------------------------------------------

Q. 아래와 같은 상황에서 어디에서 오류가 발생하는가? 왜 그런지 설명하시오 
A.	3 : 이미 메모리를 해제했기때문에 또다시 해제하려고 하면 double-free문제가 발생합니다. 
	8 : pb는 동적 메모리가 아니라 정적 변수인 doit을 가리키고 있으므로 delete할 수 없다. 
		// 다르게 이야기하자면
		delete는 반드시 동적으로 할당된 메모리(new)에만 사용해야합니다. heap메모리 관리 목적으로 만들어졌기 때문인데 
		int doit = 2 로 스택메모리에 저장되기때문에 delete를 사용하여 메모리를 해제할 수 없습니다. 
	(-> 	스택메모리 함수이기때문에 함수가 끝나면 자동으로 해제되어 따로 해제할 필요가 없습니다. )
	
-------------------------------------------------

Q. malloc과 new 언제 사용하는가?
A. 일반적으로 new가 더 안전하지만, 메모리의 재할당이 빈번하게 발생하는경우 realloc을 통해 메모리 크기를 동적으로 조정하는 malloc이 더 효과적일 수 있습니다. 
	예를들어, 배열크기를 유연하게 조정해야하는경우, realloc을 사용하는것이 효율적일 수 있다고 생각합니다. 
	
-------------------------------------------------

Q. calloc, malloc, realloc, new의 차이점에 대해 설명하시오 
A. 	malloc = 동적할당
		메모리 할당 : O
		초기화 : X
		반환타입 : void*
		기타 : 실패시 NULL리턴

	calloc = 동적할당
		메모리 할당 : O / 연속적 메모리공간
		초기화 : 0으로 초기화 
		반환타입 : void*
		기타 : 

	realloc = 기존 메모리 크기 조정
		메모리 할당 : O
		초기화 : 기존메모리는 유지 + 추가부분 초기화 x
		반환타입 : void*
		기타 : 

	new = c++ 동적할당
		메모리 할당 : O
		초기화 : o
		반환타입 : 해당타입의 포인터 
		기타 : 생성자 호출
		
-------------------------------------------------

Q.	메모리 할당이 제대로 되지 못한 상황에서 new의 동작반응에 대해 설명하시오 
A.	
	동작방식
		1. 메모리 할당 실패 발생:
			new 연산자는 힙 메모리 할당에 실패하면 현재 등록된 new-handler를 호출합니다.
		2. new-handler의 반환 여부:
			new-handler가 성공적으로 메모리를 확보하거나 할당 실패를 복구하면, 다시 메모리 할당을 시도합니다.
			new-handler가 아무 작업도 수행하지 못하거나 예외를 던지면, 최종적으로 bad_alloc 예외가 발생합니다.
		3. 이후작업 - set_new_handler 사용:
			std::set_new_handler를 사용하여 사용자 정의 new-handler를 등록합니다.
			이 함수는 이전에 설정된 new-handler를 반환하며, 필요 시 복구 작업을 수행할 수 있습니다.

	예외처리방법
		1. try-catch
		2. set_new_handler : 사용자 지정 new handler지정
		3. nothrow : nullptr 반환.
		
	예시코드
		1. try-catch
			try {
				int *arr = new int[100000000];
			}
			catch (std::bad_alloc &exception) {
				cout << "exception :" << exception.what() << endl;
				std::abort();
			}
		
		2. set_new_handler
			void handler() {
				cout << "out of mem" << endl;
				std::abort();
			}

			int main(void) 
			{
				std::set_new_handler(handler);
				while (true) {
					int *arr = new int[100000000];
				}
				return 0;
			}

		3. nothrow
			int main(void) 
			{
				while (true) 
				{
					int *arr = new(std::nothrow) int[100000000];
					if (arr == NULL) 
					{
						cout << "NULL return" << endl;
						std::abort();
					}
				}
				return 0;
			}
	
-------------------------------------------------