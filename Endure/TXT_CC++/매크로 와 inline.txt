[질문목록]
Q. 매크로에 대해 설명하시오 

Q. 인라인에 대해 설명하시오

Q.  전부다 inline화 하면 빨라서 좋은건가요?

Q. 매크로 VS 인라인 VS 람다식

Q. define보다 const int를 선호하는 이유 ? 

-----------------------------------------------

Q. 매크로에 대해 설명하시오 
A.	정의 : 전처리기 지시문으로, 컴파일 이전에 특정 텍스트를 다른 코드로 대체하는 기능을 의미합니다. 

	왜 사용하는가 ? : 
	1. 코드 재사용
		반복되는 코드를 매크로로 정의하여 중복을 줄이고 유지보수를 간소화 하기 위해 
	2. 상수 정의
		프로그램 전반에서 사용되는 상수 값을 매크로로 정의하면 유지보수와 가독성이 좋아집니다. 
	3. 조건부 컴파일 
		#ifdef같은 매크로 조건문을 통해 코드의 일부를 컴파일 여부에 따라 선택적으로 포함할 수 있도록 합니다. 
	4. 성능 최적화 
		단순히 텍스트 치환이므로 함수 호출보다 빠를 수 있습니다. (함수호출에 따른 오버헤드가 없어서)

	단점 및 주의사항 :
	1. 디버깅이 어렵다. 
		텍스트 치환이므로 오류 발생시 디버깅이 어렵다. 
	2. 타입 안정성 부족
		텍스트 치환이기 떄문에 타입 검사를 하지 않습니다. 따라서 예상치 못한 동작을 할 수 있습니다. 
	3. 메모리 관련
		코드를 치환하는 방식으로 동작하기때문에 매크로 자체가 데이터를 저장하거나 메모리를 차지하지 않으며 단순히 확장될뿐이다. 
	
	사용 경험 :
	저의경우, 프로젝트 내에서 ANIM_FILE_PATH 그리고 NONE_ANIM_FILE_PATH 와 같이 경로를 매크로로 치환하여 파일디렉토리 순회를 통해 한번에 로드가 가능하도록 하였습니다. 
	
-----------------------------------------------

Q. 인라인에 대해 설명하시오
A.	
	1. 정의 
		함수 호출 오버헤드를 줄이기 위해 함수의 "기계어 코드"를 호출 지점에 직접 삽입하는 방식이다.
		컴파일러는 inline을 참고하지만, 최적화 여부를 자체적으로 판단하여 인라인을 적용할 수도 있고 안 할 수도 있다.

	왜 사용하는가 ?
	1. 함수 호출로 인한 오버헤드를 줄일 수 있다. 
	2. 코드가 간결하고 가독성이 향상된다. 
	3. 디버깅이 가능하다.

	인라인이 불가능한 경우 - 컴파일러가 자동으로 처리하지 않는다. 
	1. 함수가 너무 크고 복잡할경우
	2. 재귀함수 - 호출지점이 동적으로 결정되므로 모든 호출을 인라인으로 대체하는것이 불가능하다. 
	3. 가상함수 - 가상함수는 런타임에 호출대상이 결정되고 인라인은 컴파일타임에 함수 호출위치에 대체되는것으로 시기가 맞지 않는다. 
	-> 작고 자주 호출되는 함수에 대해서만 한다. 
	
-----------------------------------------------

Q.  전부다 inline화 하면 빨라서 좋은건가요?
A.  함수를 인라인하면 호출 오버헤드는 줄어들지만, 코드 크기가 커지고 캐시 효율성이 떨어질 수 있다.

	1. 코드 크기(Code Bloat) 증가 → 캐시 효율성 저하
		인라인된 함수가 많아질수록 실행 파일의 크기가 커짐.
		CPU 캐시에 들어가는 코드 크기가 커지면, 캐시 미스(Cache Miss) 발생 가능성 증가.
		캐시 미스가 많아지면 오히려 실행 속도가 느려질 수 있음.

	2. 컴파일 시간 증가
		인라인된 코드가 많으면 컴파일러가 최적화하는 데 시간이 오래 걸림.
		함수가 여러 번 인라인되면, 동일한 코드가 여러 개 복사되므로 컴파일 시간이 증가함.

	3. 디버깅이 어려워짐
		인라인된 함수는 실제 호출 위치에서 직접 실행되므로, 디버깅할 때 함수 스택이 보이지 않을 수 있음.
		문제 발생 시 어느 코드에서 오류가 발생했는지 추적하기 어려움.

-----------------------------------------------

Q. 매크로 VS 인라인 VS 람다식
A.		특징				매크로					인라인 함수				람다식
	타입 안전성			없음						있음						있음
	디버깅 가능 여부		불가능					가능						가능
	외부 변수 접근		불가능					불가능					가능 (캡처)
	메모리 사용			없음						상황에 따라 다름			캡처 시 메모리 사용
	유연성				조건부 컴파일에 유리		재사용에 적합				간단한 작업에 적합

-----------------------------------------------

Q. define보다 const int를 선호하는 이유 ? 
A. define의 경우 전처리 지시문으로 컴파일 시점에 소스코드에서 해당 텍스트를 직접 치환합니다. 따라서 디버깅을 할 수 없으며, 
	만약 상수값을 사용했을때 컴파일 에러가 나타난다면 해당 상수값으로 치환된 값으로 나타나게 됩니다. 
	
	예를들어, #define ration 1.65 라고 하였다면 
	1.65라는 값이 어디서 나타난것인지 찾아야합니다. 
