Q. 가상함수에 대해 설명하시오 

Q. 가상함수 테이블이란 무엇인가

Q. 추상클래스의 포인터 변수 선언이 가능한가?

Q. 다중상속에서 가상함수 테이블이란

Q. vtable 의 크기와 생성시점, 성능에 대해 설명하시오 

Q. 가상소멸자에 대해 설명하시오 

Q. 소멸자에서 다른 가상 함수를 호출할 때 주의사항

Q. 가상 함수가 없으면 vptr/vtable이 존재할까?

----------------------------------------------
Q. 가상함수(virtual)에 대해 설명하시오 
A.	
	1. 정의
		- C++에서 부모 클래스에서 선언하고, 자식 클래스에서 재정의(override)할 수 있는 함수
		- 'virtual' 키워드를 사용하여 선언
		- 런타임 시 동적바인딩 진행

	2. 특징
		- 부모 클래스 포인터(또는 참조)로 자식 객체를 호출해도 자식 클래스의 함수가 실행됨
			-> Parent* a = new Derived
		- 동적 바인딩(Dynamic Binding)을 사용
		- 최소 하나의 가상 함수가 있으면 해당 클래스는 vtable을 가짐
		- 소멸자를 가상으로 선언하지 않으면 자식 객체의 소멸자가 호출되지 않을 수 있음

	3. 장점
		- 런타임 다형성 지원
		- 다양한 객체를 하나의 인터페이스로 처리 가능
		- 유연하고 확장 가능한 코드 작성 가능 (ex. 게임에서 다양한 Enemy 타입 처리)
		
	4. 단점
		- 정적 바인딩보다 호출 속도가 느림 (vtable 참조 필요)
		- 메모리 오버헤드 (vptr 추가)
		- 디버깅과 구조 파악이 어려울 수 있음
		- 가상 함수가 많아지면 설계가 복잡해질 수 있음
		
	5. 작동 원리
		Base* A = new Derived();
		A->speak(); // 어떤 일이 일어나는가?
		
		-(1). 객체 생성 시
			new Derived()를 하면, Derived 객체 내부에 vptr이 생성됩니다.
			이 vptr은 Derived 클래스의 vtable 주소를 가리킴.
		-(2) 실제 호출 흐름 (어셈블리 관점):
			A가 가리키는 객체 주소에서 vptr을 읽음 → *(A) 에서 vptr 추출
			vptr이 가리키는 테이블(=vtable)에서 speak 함수의 포인터를 읽음
			(예: vtable[0]에 Derived::speak() 주소 저장)
			이 주소를 통해 간접 호출 (indirect call) 수행

	6. 컴파일러 최적화
		- 인라인 캐싱: 자주 호출되는 가상 함수의 경우, 컴파일러가 호출 지점에 캐시를 만들어 vtable 룩업을 줄일 수 있음
		- 디버깅 정보 최적화: 릴리스 모드에서는 디버깅 정보가 vtable에서 제거되어 크기가 줄어들 수 있음
		- 상수 전파: 컴파일러가 객체의 실제 타입을 알 수 있는 경우, 가상 함수 호출을 직접 호출로 최적화할 수 있음
----------------------------------------------

Q.	가상함수 테이블이란 무엇인가
A.	클래스에 가상 함수(virtual)가 포함된 경우, 컴파일러가 생성하며, 가상 함수의 주소를 저장하는 테이블입니다.
	
	Vtable 특징
	1) 클래스 단위로 생성 : 각 클래스에 대해 하나의 Vtable이 생성됩니다. 클래스의 모든 객체는 같은 Vtable을 공유합니다.
	2) 가상 함수만 포함 : Vtable에는 가상 함수(virtual)만 포함됩니다.
		비가상 함수는 정적 바인딩(Static Binding)으로 처리되므로 Vtable과 무관합니다.
	3) 재정의된 함수로 대체 : 자식 클래스에서 가상 함수를 재정의하면, 부모 클래스의 해당 가상 함수 포인터가 자식 클래스의 함수로 대체됩니다.
	4) Vtable은 컴파일러가 관리 : Vtable과 VPTR의 생성 및 관리는 컴파일러에 의해 자동으로 처리됩니다.

	장점
		다형성 지원: 부모 포인터를 통해 자식 클래스의 재정의된 함수를 호출할 수 있습니다.
		유연성: 런타임에 객체 타입에 따라 동작을 변경할 수 있습니다.
	단점
		성능 오버헤드: VPTR과 Vtable을 사용한 간접 호출로 인해 정적 바인딩보다 약간 느립니다.
		메모리 오버헤드: Vtable과 VPTR로 인해 약간의 추가 메모리가 필요합니다.
		구조 복잡성: 다중 상속과 함께 사용될 경우, Vtable 관리가 복잡해질 수 있습니다.
		
-------------------------------------------------------
	
Q. 추상클래스의 포인터 변수 선언이 가능한가? (CAnimal* pAnim;)
A. 
	가능합니다.
	해당 코드는 메모리에 할당된 객체가 아니라 포인터 변수를 선언하는 과정이기때문에 추상 클래스여도 문제가 되지 않습니다. 
	다만, Shape shape; // 오류: 추상 클래스의 객체 생성 불가
	
-------------------------------------------------------

Q. 다중상속에서 가상함수 테이블이란
A.	
	단일상속 : VPTR은 하나만 존재하며, 객체는 자신이 속한 클래스의 Vtable을 가리킵니다.
		-> 자식클래스에서 부모 클래스의 가상 함수 주소가 포함됩니다.
		= 단일 상속에서는 함수 이름 충돌이 발생하지 않으므로, 부모 VPTR이 따로 필요하지 않습니다.
	다중상속 : 모 클래스에서 같은 이름의 함수가 존재할 가능성이 있어서 부모 클래스마다의 독립적인 VPTR을 가집니다. 
		-> 본인 제외 부모의 수만큼의 VPTR를 갖는다. 

	+Q. 그렇다면 재정의될경우 ?
		자식클래스에서 부모클래스의 가상함수를 재정의할경우 부모클래스의 Vtable에는 해당 함수 항목이 자식클래스의 함수로 업데이트된다. 

-------------------------------------------------------

Q. vtable 의 크기와 생성시점, 성능에 대해 설명하시오 
A.	
	1. vptr (virtual table pointer)
		- 각 객체가 내부에 가지고 있는 포인터
		- 해당 객체가 속한 클래스의 vtable을 가리킴
		- 객체가 할당된 메모리(힙/스택) 내부 맨 앞(offset 0) 부분에 위치 
		- 객체가 생성될 때 자동으로 설정됨
		- 객체가 힙, 스택, 전역 어디에 있어도 vptr은 객체 내부에 존재
		
	2. vtable (virtual table)
		- 클래스 단위로 존재하는 함수 포인터 테이블
		- 클래스의 가상 함수들이 오버라이드된 실제 구현 주소를 담음
		- 데이터 영역(.rodata 또는 코드 세그먼트)에 위치 
		- 클래스가 로드될 때 생성되고 공유됨 (객체마다 생성되지 않음)
		- 일반적으로 메모리의 데이터 영역(data segment)에 존재 

-------------------------------------------------------
	
Q.	가상소멸자에 대해 설명하시오 
A.	정의 : 부모 클래스 포인터를 통해 자식 클래스 객체를 삭제할 때, 자식 클래스의 소멸자가 먼저 호출되도록 보장합니다.

	왜 사용하는가 ?
		1. 동적 메모리 해제에서 자식 클래스의 소멸자 호출 보장
			가상 소멸자를 사용하지 않으면 자식 클래스의 소멸자가 호출되지 않기때문에 자식 클래스에서 할당한 리소스가 해제되지 않아 메모리 누수가 발생할 수 있습니다.

	동작 원리
		1) 가상 함수 테이블(Vtable) 활용
			가상 소멸자도 다른 가상 함수처럼 Vtable에 등록됩니다.
			객체 삭제 시 VPTR을 통해 Vtable에서 소멸자의 주소를 조회하고, 자식 클래스의 소멸자가 먼저 호출됩니다.
		2) 호출 순서
			자식 클래스의 소멸자가 호출됨.
			부모 클래스의 소멸자가 호출됨.

----------------------------------------------

Q.	소멸자에서 다른 가상 함수를 호출할 때 주의사항
A.	
	소멸자는 자식 클래스 → 부모 클래스 순서로 호출됩니다.
	따라서, 자식 클래스의 소멸자가 실행될 때는 정상적으로 동작하지만, 부모 클래스의 소멸자가 실행 중일 때 자식 클래스의 가상 함수는 호출되지 않습니다.
	부모 클래스의 소멸자에서 가상 함수를 호출하면, 현재 Vtable이 부모 클래스의 수준으로 설정되므로, 자식 클래스에서 재정의된 함수는 호출되지 않습니다.

	[순서 정리]
	파생클래스 소멸자 호출 > 파괴
	> 객체의 vptr는 이미 부모클래스의 vtable을 가리키도록 변경됨
	> 부모클래스 소멸자 호출 > 가상함수 호출시 파파생클래스 override가 아닌 부모클래스 호출 > 파괴
		
----------------------------------------------

Q. 가상 함수가 없으면 vptr/vtable이 존재할까?
A.
	가상 함수가 없으면 vptr과 vtable은 존재하지 않습니다.
	vptr과 vtable은 컴파일러가 다형성을 처리할 수 있도록 지원하는 메커니즘이기 때문에, 
	가상 함수가 없는 클래스에는 이러한 메커니즘이 사용되지 않으며, vptr과 vtable이 존재하지 않습니다.