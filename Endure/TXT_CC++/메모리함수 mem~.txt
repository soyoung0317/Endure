Q. memcpy에 대해 설명하시오 

Q. memmove에 대해 설명하시오 

Q. memset에 대해 설명하시오

Q. memcpy 와 memmove의 차이점에 대해 설명하시오 

Q. 클래스 초기화시 memset(this, 0, sizeof(*this)) 하는것에 대해 
-------------------------------------------------

Q. memcpy에 대해 설명하시오 
A.	1. 정의
		C/C++에서 메모리의 특정 영역을 다른 영역으로 복사하는 표준 라이브러리 함수.
		# 헤더 파일: <string.h> (C), <cstring> (C++)
		# 사용방법 : void* memcpy (void* dst, const void* src, size_t num)
					memcpy(복사받을 메모리, 복사할 메모리, 길이)
					두번째 인자(src)에 있는 원본을 세번째 인자(num)만큼의 길이 만큼 복사해서첫번째 인자(dst)에 붙여 넣는 함수 입니다.

	2. 사용하는 이유
		- 효율적인 메모리 복사: 특정 크기만큼의 데이터를 "빠르게 복사"해야 할 때 사용.
		- 타입에 구애받지 않음: 포인터를 통해 전달받은 메모리의 데이터를 크기만큼 복사.
		- 겹치지 않는 영역에서의 최적화: 원본과 대상 메모리 영역이 겹치지 않는 경우 성능이 최적화되어 있습니다.

	3. 주의할 점
		- 겹치는 메모리 영역 : memcpy는 원본과 복사 대상 메모리 영역이 겹칠 경우 데이터 손상을 초래할 수 있습니다.
			-> 이러한 경우에는 memmove를 사용하는 것이 적합합니다.
		- 복사 크기 확인 : 복사 크기를 잘못 설정하면 메모리 오버플로우 또는 원하지 않는 데이터 접근이 발생할 수 있습니다.
		- 타입 안정성 없음 : 단순히 메모리를 복사하므로 데이터의 논리적 의미는 보존되지 않을 수 있습니다. (예: 구조체 내 포인터 복사 시 얕은 복사 발생)
	 
	 4. 특징
		- 빠른 복사속도 
			: 내부적으로 CPU의 최적화된 메모리 복사 명령어를 사용하여 겹치는 메모리 확인 작업이 생략되기 때문에 복사속도가 빠르다. 
-------------------------------------------------

Q. memmove에 대해 설명하시오 
A.	1. 정의 
		C/C++에서 메모리의 특정 영역을 다른 영역으로 복사하는 표준 라이브러리 함수.
		복사 대상 메모리 영역과 원본 메모리 영역이 겹칠 경우에도 안전하게 동작하도록 설계되었습니다.
		# 헤더 파일: <string.h> (C), <cstring> (C++)
		# 사용방법 : void* memmove (void* dest, const void* src, size_t num);
					src가 가리키는 메모리로 부터 num 바이트 사이즈 만큼 dest가 가리키는 메모리에 옮깁니다.

	2. 사용하는 이유
		- 겹치는 메모리 복사 처리 : 원본과 대상 메모리 영역이 겹칠 가능성이 있을 때 사용.
		- 안전성 보장 : 특히 버퍼 이동이나 데이터 재배열과 같은 작업에서 안전하게 사용됩니다.

	3. 주의할 점
		- 성능이 memcpy보다 느림 : 겹침 여부를 판단하고 복사 방향을 조정하는 추가 작업이 필요하므로 memcpy보다 속도가 느립니다.
		- 복사 크기와 메모리 경계 확인 필요 : 복사 크기를 잘못 설정하거나 유효하지 않은 메모리 주소를 참조하면 런타임 에러 발생.
			(실제 메모리 주소와 크기가 런타임에 결정되므로 런타임 에러 발생임)

	4. 특징
		- 메모리 복사 수행시, 중간에 버퍼를 이용하게 되므로 dst 과 src 의 해당하는 범위가 겹쳐져도 문제는 없다.
-------------------------------------------------

Q. memset에 대해 설명하시오
A.	1. 정의 
		C/C++에서 메모리의 특정 영역을 지정한 값으로 채우는 표준 라이브러리 함수.
		# 헤더 파일: <string.h> (C), <cstring> (C++)
		# 사용방법 : void* memset(void* ptr, int value, size_t num);
					- ptr주소에 value내용으로 num만큼 채운다. 
					- int 타입으로 받지만 내부에서는 unsigned char 로 변환되어서 저장됩니다. 즉 'a' 이런것을 넣어도 무방하다.
		# 반환값 : 성공하면 첫번째 인자로 들어간 ptr을 반환, 실패한다면 NULL을 반환
		# 예시코드
			char arr1[] = "blockdmask blog";    
			memset(arr1, 'c', 5 * sizeof(char)); // cccccdmask dog

	2. 사용하는 이유
		- 초기화: 메모리 블록을 특정 값으로 초기화할 때.
				예: 배열, 구조체, 동적 메모리의 초기값 설정.
		- 빠르고 효율적: 반복문 대신 CPU 수준에서 최적화된 메모리 연산을 사용하므로 성능이 우수.
		- 특정 값 설정: 모든 바이트를 같은 값으로 설정할 때.

	3. 주의할 점
		- 바이트 단위 작업 : memset는 메모리의 각 바이트를 동일한 값으로 설정합니다.
							따라서 int, float 등과 같은 타입을 초기화할 때는 오작동이 발생할 수 있습니다.
							모든 바이트를 0으로 설정할 때만 정상적으로 동작
			# 예시 - 배열 요소를 1로 설정하는 것이 아니라, 각 바이트를 0x01로 설정합니다.
				int arr[5];
				memset(arr, 1, sizeof(arr)); // 잘못된 초기화 
				int 는 4바이트이기때문에 각각의 바이트마다 0x01로 설정 = 0x01010101 (16진수 값) = (10진수) 16,843,009
		
		- 값 범위 제한 : 설정 값은 unsigned char로 변환되어 사용됩니다. 즉, 0~255 범위를 벗어난 값은 올바르게 처리되지 않을 수 있습니다.
		- 메모리 할당 확인 : 메모리를 설정하기 전에 유효한 주소인지 확인해야 합니다. 할당되지 않은 메모리에 접근하면 런타임 에러가 발생합니다.
-------------------------------------------------

Q. memcpy 와 memmove의 차이점에 대해 설명하시오 
A.	memcpy: 겹치는 메모리 영역에서는 주의필요. 더 빠름.
		(안정성 체크 X -> 겹치는 메모리 영역에 대해 손실발생). 
	memmove: 겹치는 메모리 영역에서도 안전. 약간 느림.

-------------------------------------------------

Q. 클래스 초기화시 memset(this, 0, sizeof(*this)) 하는것에 대해 어떻게 생각하는가?
A.
	1. 안전하지 않다. 
		this포인터를 통해 클래스를 0초기화 한것이다. 
		문제는 클래스의 vtable을 가리키는 주소가 객체 맨앞에 생성된다. 
		ex. vtable(8) + 멤버변수(4) + 멤버변수 (8) + ... 
		std::string, std::vector 같은 복잡한 멤버 객체가 있으면 내부 상태가 망가지고, 심하면 크래시 발생