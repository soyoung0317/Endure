Q. 이동의미론에 대해 설명하시오 

Q. 그럼 이동만 사용하면 되는것 아닌가 ? 

Q. 이동이 효율적이지 않은경우에 대해 설명해보시오.

-------------------------------------------------------

Q. 이동의미론에 대해 설명하시오 
A.  정의 : C++11에서 도입된 기능으로, 객체의 복사가 아닌 자원의 소유권을 이동하여 복사 오버헤드를 줄이고 성능을 최적화하는 기법을 말한다. 

	왜 사용하는가?
		1. 성능 최적화 
			: 객체를 복사하면 새로운 메모리를 할당하고 데이터를 복사해야 하므로 성능 비용이 높습니다.
				따라서, 복사 대신 자원의 소유권을 이전하여 이러한 오버헤드를 제거한다. 
		2. 동적 리소스 관리
			: 동적 메모리, 파일 핸들, 네트워크 소켓 등 소유권 기반 리소스 관리를 효율적으로 수행할 수 있습니다.

	주요 개념
		1. 이동생성자
			ClassName(ClassName&& other);
			: 이동 생성자는 객체를 복사하는 대신 자원의 소유권을 이동합니다.
			: 자원의 이동 후, 원래 객체는 더 이상 유효하지 않은 상태가 되며, 이를 "빈 상태(empty state)"로 설정합니다.

		2. 이동 할당 연산자 (Move Assignment Operator)
			ClassName& operator=(ClassName&& other);
			: 기존 객체에 임시 객체의 자원을 이동 대입합니다.
			: 이동 후, 원래 객체의 자원을 안전하게 해제해야 합니다.

	특징
		1. 이동이후의 객체
			: 이동된 객체는 일반적으로 "빈 상태(empty state)"로 설정되며, 리소스가 더 이상 유효하지 않음.
			: 그러나 소멸자가 호출될 수 있으므로, 유효한 상태(예: nullptr 설정)를 유지해야 함.
		2. 성능 최적화
			: 대규모 데이터 구조(예: 동적 배열, 문자열, 벡터 등)의 복사 비용을 줄이는 데 효과적. 복사생성자보다 빠르다.
			
-------------------------------------------------

Q. 그럼 이동만 사용하면 되는것 아닌가 ? 
A.	
	(1)  원본 객체를 계속 사용해야 하는 경우
		이동 연산은 원본 객체를 비워버리므로, 이후 원본 객체를 다시 사용할 수 없다!

	(2) lvalue(일반 변수)는 기본적으로 이동할 수 없다
		일반적인 변수(lvalue)는 이동이 아니라 복사가 기본 동작이다
		
	(3) 소유권 공유 필요
		이동 연산(Move)는 하나의 객체만 리소스를 소유하는 방식이다.
		따라서, 여러 객체가 같은 리소스를 공유해야 하는 경우에는 이동을 사용할 수 없다.

-------------------------------------------------

Q. 이동이 효율적이지 않은경우에 대해 설명해보시오.
A.
	1. array에서 move사용
		다른 STL 컨테이너의 경우 자신들의 내용물을 힙에다 저장해둔다. 
		그래서 move 연산을하면 저장공간의 주소만 swap하여 빠르게 동작할 수 있다.
		하지만 std::array의 경우 그러한 힙 영역에 대한 포인터가 없다! 
		왜냐하면 std::array의 원소들은 std::array 객체 자체에 저장되기 때문이다. 
		그렇다면 std::array의 move 동작은 저장된 원소들 하나하나를 move하는 작업이 필요하다.

	2. string
		move 동작은 일반적으로 상수시간(포인터 교체)만에 이루어진다. 그러나 
		std::string은 길이가 길지 않은 문자열에 대해서 Small String Optimizatoin(SSO)라는 최적화 기법을 제공한다. 
		이것은 따로 힙에 데이터를 저장하지 않고, 적은 양의 데이터의 경우 객체 내부 버퍼에 저장을 하는 방법이다. 
		그러면 SSO로 구성된 짧은 std::string의 경우 std::array의 move 동작과 같은 이유에서 효율을 기대할 수가 없다. 
		실제로 문자열의 길이가 긴 경우보다 짧은 경우가 많기 때문에(일반적인 경우) std::string의 move는 전체적인 효과가 뛰어나다고 볼 수는 없을 것이다.
