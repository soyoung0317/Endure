Q. 스마트 포인터에 대해 설명하시오 

Q. unique_ptr 실패하는 예시

Q. unique_ptr와 shared_ptr의 성능차이 

Q. weak_ptr 를 사용하는 이유는 ? 

Q. 프로젝트에서 RefCnt 직접 사용한 이유 ? 

-------------------------------------------------

Q.  스마트 포인터에 대해 설명하시오 
A.  스마트 포인터는 메모리관리를 자동화하고 동적할당된 객체의 소멸을 자동으로 처리해주는 포인터입니다. 
    메모리 누수와 같은 문제를 예방할수 있다는 장점이 있습니다.

    unique_ptr 
        독점 소유권 개념의 포인터
        복사할 수 없고, 이동(move)만 가능
        리소스의 유일한 소유자가 되어 소멸 시 자동으로 리소스 해제
        오버헤드가 거의 없어 일반 포인터와 성능이 비슷
        가장 많이 사용되는 스마트 포인터
    
    shared_ptr 
        공유 소유권 개념의 포인터
        참조 카운팅 방식으로 동작 (내부적으로 카운터를 유지)
        마지막 shared_ptr이 소멸될 때 리소스 해제
        약간의 오버헤드가 있음 (참조 카운팅 때문)
    
    weak_ptr 
        shared_ptr의 순환 참조 문제를 해결하기 위한 포인터
        shared_ptr이 관리하는 객체를 참조하지만 소유권은 가지지 않음
        참조 카운트를 증가시키지 않음
        객체가 아직 존재하는지 확인 가능 (expired() 메서드)

-------------------------------------------------

Q.  unique_ptr 실패하는 예시
A.  unique_ptr는 유일한 소유권을 보장하기때문에 복사하려는 시도를 할 때 컴파일 오류를 발생시킵니다. 
    -> move를 통해 소유권 이전을 해야합니다. 

    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    
    std::unique_ptr<int> ptr2 = ptr1;               // 컴파일 오류! unique_ptr는 복사할 수 없음
    std::unique_ptr<int> ptr2 = std::move(ptr1);    // ptr1의 소유권을 ptr2로 이동
    
-------------------------------------------------

Q.  unique_ptr와 shared_ptr의 성능차이 
A.  unique_ptr는 단순히 객체의 소유권만 관리하므로 성능에 거의 영향을 미치지 않지만, 
    shared_ptr는 참조 카운팅을 관리하기 때문에 성능에 영향을 줄 수 있습니다
    특히, 멀티 쓰레드 환경의 경우 참조 카운트를 업데이터하는데 있어 성능저하가 발생할 수 있습니다. 
    
-------------------------------------------------

Q. weak_ptr 를 사용하는 이유는 ? 

-------------------------------------------------

Q. 프로젝트에서 RefCnt 직접 사용한 이유 ? 