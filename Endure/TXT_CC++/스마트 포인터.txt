Q. 스마트 포인터에 대해 설명하시오 

Q. unique_ptr 실패하는 예시

Q. unique_ptr와 shared_ptr의 성능차이 

Q. weak_ptr 를 사용하는 이유는 ? 

Q. 레퍼런스 카운터(Reference Counter)는 무엇인가?

-------------------------------------------------

Q.  스마트 포인터에 대해 설명하시오 
A.  
    1. 정의
        스마트 포인터는 C++에서 동적 메모리를 안전하고 편리하게 관리하기 위해 만든 클래스 템플릿이다.
         메모리 할당과 해제를 자동으로 관리해서 메모리 누수와 잘못된 접근을 방지한다.

    2. 왜 사용하는가
        기존에 new와 delete를 직접 사용하면 메모리 해제를 깜빡하거나, 중복 해제, 잘못된 포인터 접근 등으로 인해 프로그램이 불안정해질 수 있다.
        스마트 포인터는 이런 위험을 줄이고, 예외가 발생해도 자동으로 메모리를 해제해 안전성을 높인다.
    
    3. 종류
        (1) unique_ptr 
            독점 소유권 개념의 포인터
            복사할 수 없고, 이동(move)만 가능
            리소스의 유일한 소유자가 되어 소멸 시 자동으로 리소스 해제
            오버헤드가 거의 없어 일반 포인터와 성능이 비슷
            가장 많이 사용되는 스마트 포인터
        
        (2) shared_ptr 
            공유 소유권 개념의 포인터
            참조 카운팅 방식으로 동작 (내부적으로 카운터를 유지)
            마지막 shared_ptr이 소멸될 때 리소스 해제
            약간의 오버헤드가 있음 (참조 카운팅 때문)
        
        (3) weak_ptr 
            shared_ptr의 순환 참조 문제를 해결하기 위한 포인터
            shared_ptr이 관리하는 객체를 참조하지만 소유권은 가지지 않음
            참조 카운트를 증가시키지 않음
            객체가 아직 존재하는지 확인 가능 (expired() 메서드)

-------------------------------------------------

Q.  unique_ptr 실패하는 예시
A.  unique_ptr는 유일한 소유권을 보장하기때문에 복사하려는 시도를 할 때 컴파일 오류를 발생시킵니다. 
    -> move를 통해 소유권 이전을 해야합니다. 

    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    
    std::unique_ptr<int> ptr2 = ptr1;               // 컴파일 오류! unique_ptr는 복사할 수 없음
    std::unique_ptr<int> ptr2 = std::move(ptr1);    // ptr1의 소유권을 ptr2로 이동
    
-------------------------------------------------

Q.  unique_ptr와 shared_ptr의 성능차이 
A.  
    unique_ptr는 단순히 객체의 소유권만 관리하므로 성능에 거의 영향을 미치지 않지만, 
    shared_ptr는 참조 카운팅을 관리하기 때문에 성능에 영향을 줄 수 있습니다
    특히, 멀티 쓰레드 환경의 경우 참조 카운트를 업데이터하는데 있어 성능저하가 발생할 수 있습니다. 
    
-------------------------------------------------

Q. weak_ptr 를 사용하는 이유는 ? 
A.
    1. 정의
        std::weak_ptr는 std::shared_ptr가 관리하는 객체를 참조하되, 참조 카운트를 증가시키지 않는 스마트 포인터다.
        즉, 소유권이 없고, 객체의 생명 주기에 영향을 주지 않는 약한 참조(Weak Reference)를 제공한다.

    2. 왜 사용하는가
        std::shared_ptr끼리 서로를 참조하는 순환 참조(Cyclic Reference)가 발생하면 참조 카운트가 0이 되지 않아 메모리 누수가 생긴다.
        이 문제를 해결하기 위해, 서로 강한 소유권이 필요한 경우는 shared_ptr를 사용하고, 순환 참조를 끊기 위해 약한 참조가 필요한 경우 weak_ptr를 사용한다.

-------------------------------------------------

Q. 레퍼런스 카운터(Reference Counter)는 무엇인가?
A.
    1. 정의
       객체가 몇 개의 포인터에 의해 참조되고 있는지를 추적하는 숫자 카운터다. 
       주로 std::shared_ptr 같은 스마트 포인터 내부에서 사용되어, 객체의 생명 주기를 관리한다.

    2. 왜 사용하는가
        동적 할당한 객체를 여러 포인터가 공유할 때, 누가 언제 메모리를 해제해야 할지 판단하기 어렵다.
        레퍼런스 카운터를 통해 현재 객체를 참조하는 포인터 수를 기록해서, 마지막 참조자가 사라질 때 자동으로 메모리를 해제할 수 있도록 한다.

    3. 특징
        (1) 장점
            객체가 안전하게 공유되고, 메모리 누수를 방지할 수 있다.
            메모리 해제를 수동으로 관리하지 않아도 돼서 편리하다.
            
        (2) 단점
            참조 카운터를 관리하는 데 오버헤드가 발생한다.
            순환 참조(Cyclic Reference)가 발생하면 카운터가 0이 되지 않아 메모리 누수가 발생할 수 있다.
            -> std::weak_ptr 를 통해 순환참조문제를 해결한다. 

