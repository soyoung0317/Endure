Q. 깊은복사와 얕은복사에 대해 설명하시오 

Q. 얕은 복사에서 발생할 수 있는 문제점은 무엇인가요?

Q. Rule of Three / Five / zero 규칙에 대해 설명하시오 
-------------------------------------------------

Q. 깊은복사와 얕은복사에 대해 설명하시오 
A.	
	1. 정의
		- 얕은 복사 (Shallow Copy):
			객체의 멤버 변수들을 비트 단위로 그대로 복사하는 방식
			포인터 변수의 경우 주소값만 복사되어 원본과 복사본이 같은 메모리를 가리키게 됨
			C++에서 기본 복사 생성자와 대입 연산자는 얕은 복사를 수행
		
		- 깊은 복사 (Deep Copy):
			포인터가 가리키는 실제 데이터까지 새로 할당하여 복사하는 방식
			원본과 복사본이 독립적인 메모리를 가지게 됨
			사용자 정의 복사 생성자와 대입 연산자를 통해 구현해야 함
		
	2. 왜 사용하는가
		얕은 복사는 간단한 복사가 필요할 때 사용됩니다. 복사한 객체가 원본 객체와의 관계를 유지하면서 변경할 필요가 없는 경우에 유용합니다.
		
		깊은 복사는 복사된 객체가 원본 객체와 독립적으로 동작해야 할 때 필요합니다. 
		예를 들어, 동적 메모리나 자원을 가진 객체를 복사할 때, 원본과 복사본이 서로 영향을 미치지 않도록 하려면 깊은 복사를 사용해야 합니다.

	3. 장점과 단점
		- 얕은 복사
			장점	:
				빠르고 간단한 방식입니다. 복사 과정이 비교적 빠르며, 메모리 사용이 적습니다.
				자원을 공유하려는 경우, 불필요한 메모리 복사를 피할 수 있습니다.
			단점	:
				원본 객체와 복사된 객체가 동일한 자원을 공유하기 때문에, 한 객체에서 자원을 수정하면 다른 객체에도 영향을 미칩니다.
				원본이나 복사본 중 하나가 소멸될 때 메모리가 해제되면, 다른 하나는 댕글링 포인터가 됨
				얕은 복사 후 한 객체를 소멸해도, 원본 객체가 소멸되는 것은 아니다.
			예시 : 
				포인터 없이 값타입만 있어서 독립적인 객체 생성이 가능한경우 
				(하지만 둘이 같은 자원을 공유하고 있어서, 하나가 소멸되면 나머지는 위험한 상태가 된다.)
					ex. bullet, 분신시스템, 

		- 깊은 복사
			장점	:
				독립적인 복사본을 만들 수 있기 때문에, 원본 객체와 복사된 객체가 서로 영향을 미치지 않습니다.
				복사된 객체가 자원을 독립적으로 관리하므로, 메모리 관리에서 안전합니다.
			단점	:
				비용이 많이 듭니다. 깊은 복사는 메모리를 복사하고 자원을 재귀적으로 복사하기 때문에 성능이 상대적으로 떨어지고, 메모리 사용량이 많습니다.
				복사할 객체의 구조가 복잡하거나 다단계로 중첩된 경우, 복사 로직이 복잡해질 수 있습니다.
			예시 : 
				몬스터를 독립적으로 객체 생성해야하는경우 

-------------------------------------------------
		
Q. 얕은 복사에서 발생할 수 있는 문제점은 무엇인가요?
A. 
	1. 자원 공유로 인한 오류
		얕은 복사는 객체가 가진 포인터나 참조를 복사하는데, 이는 두 객체가 동일한 메모리 주소를 참조하게 만듭니다. 
		이로 인해 두 객체가 같은 자원을 공유하게 되며, 하나의 객체가 자원을 변경하거나 삭제하면 다른 객체에도 영향을 미치게 됩니다.

	2. 예기치 않은 데이터 변경
		얕은 복사는 객체 간의 자원을 공유하기 때문에, 하나의 객체에서 자원을 변경하면, 다른 객체도 그 변경된 값을 참조하게 됩니다. 
		이는 원치 않는 데이터 수정을 초래할 수 있습니다.

	3. 소멸자 호출 시 문제
		얕은 복사에서 객체의 포인터를 공유하기 때문에, 소멸자에서 자원 해제를 제대로 처리하지 않으면 메모리 누수나 다시 해제된 메모리 참조 문제가 발생할 수 있습니다.
		
-------------------------------------------------

Q. Rule of Three / Five / zero 규칙에 대해 설명하시오 
A.
	[정리]
	만약 클래스가 소멸자, 복사 생성자, 복사 대입 연산자 중 하나라도 직접 정의해야 한다면, 세 가지 모두 정의해야 함 (Rule of Three)
	C++11 이후에는 이동 생성자와 이동 대입 연산자까지 포함해 다섯 가지를 모두 정의하는 것이 좋음 (Rule of Five)
	또는 특별한 리소스 관리가 필요 없다면 모두 기본값을 사용 (Rule of Zero)

	[설명]
	Rule of 3
		Rule of 3란, 복사생성자/대입연산자/소멸자 중 하나라도 직접 정의했다면 나머지를 모두 정의(혹은 삭제)하라는 규칙이다.
		사용자 정의 소멸자를 썼다는 건 자원 관리를 한 다는 것이고, 그렇다면 default 복사생성자/대입 연산자가 제대로 작동하지 않을 것이기 때문이다.
		
	Rule of 5
		Rule of 5는 move semantics가 추가된 C++11부터 생긴 Rule of 3의 확장으로,
		rvalue를 받는 생성자와 rvalue 대입연산자도 추가로 구현하라는 뜻이다.
		하지 않을 경우 복사 과정에서 성능 손해를 볼 확률이 높기 때문이다.
		
	Rule of 0
		자원 관리를 스스로 하지 말라는 것이다. (스마트 포인터 등 RAII 객체를 사용하라)
		그러면 소멸자를 직접 구현하지 않아도 되고, 그러면 다른 Big5를 명시적으로 구현하지 않아도 RAII 등에 의해 자원이 잘 해제 될 것이고 default Big5로도 충분하다.
		ramensoup 프로젝트에서 모든 코드에 이 규칙을 적용하는 리팩토링 작업을 했었다.
		하면서 여러 케이스에 대한 Rule of 5 적용법을 찾아봤다.