Q. 포인터에 대해 설명하시오. 

Q. 이중포인터에 대해 설명하시오.

-------------------------------------------------

Q. 포인터에 대해 설명하시오. 
A.
	1. 정의	
		포인터는 변수의 메모리 주소를 저장하는 변수이다.
		즉, 포인터 변수는 특정 변수의 메모리 주소를 가리키며, 이를 통해 변수의 값을 간접적으로 조작할 수 있다.

	2. 사용하는 이유
		- 동적 메모리 할당이 가능 (new, delete 사용)
		- 함수에서 Call by Reference를 통해 값 변경 가능
		- 배열과 문자열을 효율적으로 다룰 수 있음
		- 함수 포인터를 활용하여 동적 함수 호출 가능

	3. 주의사항
		1) nullptr와 포인터 초기화
			포인터는 선언 후 초기화하지 않으면 쓰레기 값을 가질 수 있음.
			안전한 포인터 사용을 위해 nullptr로 초기화하는 것이 좋다.

		2)  포인터 연산 (Pointer Arithmetic)
			포인터는 메모리 주소를 저장하므로, 주소 연산을 할 수 있다.
			포인터에 +1을 하면 다음 메모리 위치로 이동한다.

		3) 동적 메모리 할당 (new, delete)
			new를 사용하여 힙 메모리에 동적 할당 가능
			사용이 끝나면 반드시 delete로 메모리 해제해야 함 (메모리 누수 방지)

-------------------------------------------------

Q. 이중포인터에 대해 설명하시오
A.	 
	1. 정의 
		이중 포인터(Double Pointer)란 포인터를 가리키는 포인터로, 포인터의 주소를 저장하는 포인터이다.
			int a = 10;
			int* p1 = &a;   // p1은 a의 주소를 저장하는 포인터
			int** p2 = &p1; // p2는 p1의 주소를 저장하는 포인터 (이중 포인터)

	2. 왜 사용하는가?
		- 포인터를 동적으로 변경하고 싶을 때
		- 동적 메모리 할당을 관리할 때 (이차원 배열, 리스트 등)
		- 함수에서 포인터를 수정하려고 할 때 (Call by Pointer)
		- 포인터 배열을 다룰 때
	
		전달 방식					원본 값 변경 여부		설명
		void func(int val)			변경 안됨		val의 복사본을 받으므로 원본 변경 불가
		void func(int* ptr)			변경 안됨		ptr 자체가 복사되므로 원본 포인터 변경 불가
		void func(int** ptr)		변경됨			ptr의 주소를 전달하므로 원본 포인터 변경 가능

	3. 사용예시
	int global_val = 30;

	void call_by_value(int *val) { val = &global_val; }
	void call_by_refer(int **ref) { *ref = &global_val; }
	
	int main()
	{
	        int local_val = 10;
	        int *value = &local_val;
	        int *refer = &local_val;
	
	        call_by_value(value);
	        call_by_refer(&refer);
	}

	여기서 call_by_value함수에서 value가 아니라 "value의 값(주소)"을 복사하여 val에 전달됨.
	즉, val은 value와 같은 주소를 가리키지만, 서로 다른 변수임!
	이제 val = &global_val;을 실행하면 val이 global_val을 가리키지만, 이건 복사본의 변경이므로 value에는 영향을 주지 않는다.

-------------------------------------------------
