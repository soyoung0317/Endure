Q. 스마트 포인터에 대해 설명하시오 

Q. unique_ptr 실패하는 예시

Q. unique_ptr와 shared_ptr의 성능차이 

Q. 프로젝트에서 RefCnt 직접 사용한 이유 ? 

--------------------------------

A. (24.11.19)
    스마트 포인터는 메모리관리를 자동화하고 동적할당된 객체의 소멸을 자동으로 처리해주는 포인터입니다. 
    메모리 누수와 같은 문제를 예방할수 있다는 장점이 있습니다.

    unique_ptr 
    단일 객체의 소유권을 가지며 다른 unique_ptr과 소유권을 공유할 수 없습니다.
    객체가 더이상 필요없을때 메모리를 해제합니다. 
    
    shared_ptr 
    여러개의 shared_ptr이 소유권을 공유할 수 있습니다.
    참조 카운팅을 사용하여 객체의 메모리 해제를 관리할 수 있습니다. 
    
    weak_ptr 
    객체의 소유권을 가지지 않고 참조카운트에 영향을 주지 않는 포인터입니다. 
    주로 순환 참조를 방지하기 위해 사용되는데, shared_ptr들이 서로를 참조하여 참조카운트가 0이되지않아 메모리 해제가 안되는 문제를 해결하기위해 사용합니다.

A.  unique_ptr는 유일한 소유권을 보장하기때문에 복사하려는 시도를 할 때 컴파일 오류를 발생시킵니다. 
    -> move를 통해 소유권 이전을 해야합니다. 

    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
    
    std::unique_ptr<int> ptr2 = ptr1;               // 컴파일 오류! unique_ptr는 복사할 수 없음
    std::unique_ptr<int> ptr2 = std::move(ptr1);    // ptr1의 소유권을 ptr2로 이동

A.  unique_ptr는 단순히 객체의 소유권만 관리하므로 성능에 거의 영향을 미치지 않지만, 
    shared_ptr는 참조 카운팅을 관리하기 때문에 성능에 영향을 줄 수 있습니다
    특히, 멀티 쓰레드 환경의 경우 참조 카운트를 업데이터하는데 있어 성능저하가 발생할 수 있습니다. 