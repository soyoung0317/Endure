Q. 쓰레드에 대해 설명하시오.

Q. 멀티 프로세스로 처리가능한것을 멀티 쓰레드에서 수행하는 이유는 ? 

Q. 쓰레드마다 독립적으로 할당하는것에 대해 설명하시오. 

Q. 유저모드 쓰레드와 커널모드 쓰레드에 대해 설명하시오 

Q. 쓰레드 풀에 대해 설명하시오. 

-------------------------------------

Q. 프로세스와 쓰레드에 대해 설명하시오.
A. 1. 정의
	: 프로세스 내에서 실행되는 가장 작은 단위의 실행 흐름을 의미합니다. 

	2. 특징
		1) 프로세스 
			* 독립된 메모리 공간: 프로세스는 각자 독립된 메모리 영역(코드, 데이터, 힙, 스택)을 가집니다.
			* 컨텍스트(Context) 스위칭: 운영체제는 멀티프로그램밍을 위해 CPU를 여러 프로세스에 빠르게 전환합니다. 
			* 자원 할당 단위: 프로세스는 운영체제로부터 메모리, 파일 핸들, 네트워크 소켓 등의 자원을 할당받습니다.
			* 서로 보호된 환경: 각 프로세스는 독립적이며, 하나의 프로세스가 비정상 종료되더라도 다른 프로세스에 직접 영향을 주지 않는 구조입니다.
			
			[단점]
				높은 오버헤드: 프로세스 생성과 종료가 쓰레드에 비해 비용이 많이 듭니다.
				느린 통신: 프로세스 간 통신(IPC)은 쓰레드 간 통신보다 느리고 복잡합니다.

		2) 쓰레드
		: 쓰레드는 독립적으로 스택 영역과 PC Register를 갖는다. 
			* 프로세스 자원 공유: 쓰레드는 동일 프로세스 내에서 메모리(코드, 전역 변수, 힙)를 공유합니다. 
								단, 스택(호출 스택)은 쓰레드마다 따로 할당됩니다.
			* 독립적인 실행 흐름: 각 쓰레드는 독립적으로 실행되며, 자신의 스택과 레지스터를 가집니다.
			* 빠른 컨텍스트 스위칭: 쓰레드 간 전환(Context Switch)은 프로세스 간 전환보다 훨씬 비용이 적습니다. 
								이는 자원(메모리 맵 등)을 공유하기 때문에 문맥 교환 범위가 작기 때문입니다.
			* 협업: 쓰레드들은 같은 프로세스에서 동작하므로 협업이 쉽습니다. 
								다만, 동시에 자원에 접근할 때는 동기화(Synchronization) 이슈가 발생하므로 주의해야 합니다.
			* 동기화 필요: 쓰레드가 메모리를 공유하므로, 여러 쓰레드가 동시에 공유 데이터에 접근할 경우 
							상호 배제(Mutual Exclusion)를 위한 락, 세마포어, 모니터 등의 동기화 기법을 적절히 사용해야 합니다.

			[단점]
				안정성 문제: 하나의 쓰레드가 오류를 발생시키면, 동일한 프로세스 내의 다른 쓰레드에도 영향을 미칠 수 있습니다.
				동기화의 복잡성: 공유 자원을 사용할 때 동기화가 필수적이며, 잘못된 동기화는 데드락(Deadlock)이나 레이스 컨디션(Race Condition) 등을 유발할 수 있습니다.
-------------------------------------

Q. 멀티 프로세스로 처리가능한것을 멀티 쓰레드에서 수행하는 이유는 ? 
A. 주로 자원 공유와 성능 최적화 때문입니다. 
	멀티 프로세스는 프로세스 간 메모리가 분리되어 있지만 멀티 쓰레드는 같은 프로세스의 메모리를 공유하므로, 
	바로 접근할 수 있어 통신 오버헤드가 훨씬 적고 구현도 간단합니다.

-------------------------------------

Q. 쓰레드마다 독립적으로 할당하는것에 대해 설명하시오. 
A. 쓰레드는 독립적으로 스택영역과 PC Register를 갖는다. 

	1. 스택영역
	 독립적으로 스택을 갖는다는 것은 곧 독립적으로 함수 호출이 가능하다는 것을 의미합니다. 
	 즉, 프로세스 내의 독립적인 실행 흐름을 만들기 위해 쓰레드마다 스택 영역을 갖습니다.

	 2. PC Register
	  PC Register 값은, 쓰레드가 명령어를 어디까지 수행했는 지를 나타냅니다. 
	  쓰레드는 CPU를 할당받았다가, 스케줄러에 의해서 선점당해 컨텍스트 스위칭이 일어납니다. 
	  따라서 다시 해당 쓰레드가 실행될 때 어디까지 실행이 되었는지 알아야 하므로 독립적으로 PC Register 값을 갖게 됩니다.

-------------------------------------

Q.	유저모드 쓰레드와 커널모드 쓰레드에 대해 설명하시오 
A.	1. 유저모드 쓰레드 (User Mode Thread)
		스레드 개념을 프로그래밍 레벨에서 추상화 한것
		커널이 각각의 프로세스를 스케줄링 해준다
		커널이 따로 관리하지 않고, 커널이 이 스레드에 대해서 알지도 못한다.
		
		* 특징
			유저모드에서 실행되는 쓰레드로, 운영체제의 커널 기능에 접근하지 않습니다.
			CPU에서 실제로 실행되는 단위이긴 하지만, 커널의 개입 없이 유저 레벨에서 스케줄링 됩니다
		* 장점:
			동일한 메모리 영역에서 스레드가 생성 및 관리되므로 속도가 빠르다.
			스케줄링과 동기화를 위해 System Call(커널 호출) 하지 않기 때문에 오버헤드 적음.
			커널이 관여하지 않기 때문에, 컨텍스트 스위칭이 빠름 (시스템 콜이 필요 없음)
			스케쥴링 우선순위가 지원되지 않습니다. = 사용자 영역에서 자체적으로 실행 순서를 관리
			커널이 스레드 존재를 모르기 때문에 유저모드와 커널 모드 간 전환이 없다. 프로세스 하나로 봄
		* 단점:
			여러 개의 사용자 스레드 중 하나의 스레드가 시스템 콜 등으로 중단되면 나머지 모든 스레드 역시 중단된다. 
			스케줄링 우선순위를 지원하지 않으므로 어떤 스레드가 먼저 동작할지 모름, -> 라이브러리를 통해 스케줄링한다. 

	2. 커널모드 쓰레드 (Kernel Mode Thread)
		커널레벨에서 생성 및 스케줄링 되는 스레드를 의미한다.
		커널이 각각의 쓰레드를 스케줄링 해준다

		* 특징: CPU에서 실제로 실행되는 단위, CPU스케줄링의 단위
		*	커널은 프로세스와 쓰레드를 관리하고 스케줄링하는 책임을 지고 있습니다. 
			각 쓰레드는 커널에 의해 직접 스케줄링되고, 프로세스 간 전환도 커널에서 처리합니다.
			컨텍스트 스위칭은 커널이 개입한다. = 유저모드에서 커널모드로 전환, 커널코드가 CPU에서 실행되므로 CPU의 리소스 사용, 이후 다시 유저모드로 변환해야한다. 
		* 장점:
			스레드가 시스템 호출 등으로 중단되더라도, 커널은 프로세스 내의 다른 스레드를 중단시키지 않고 계속 실행시켜준다
		* 단점:
			커널 모드로 진입하기 위한 오버헤드가 크기 때문에, 문맥 교환이 상대적으로 느리고 비효율적일 수 있습니다.
			유저 모드와 커널 모드 간 전환이 빈번하여 성능 저하


-------------------------------------
	
Q. 쓰레드 풀에 대해 설명하시오. 
A.
	1. 정의
		쓰레드 풀(Thread Pool) 은 미리 생성된 쓰레드들을 유지하면서 작업(Task)을 할당하여 실행하는 방식이다.
		쓰레드를 필요할 때마다 생성하는 것이 아니라, 미리 생성해두고 재사용(Reuse)함으로써 성능을 최적화할 수 있다.

	2. 필요성
		(1) 기존 방식 (쓰레드 생성 & 삭제)
			매번 새로운 작업을 실행할 때마다 std::thread 또는 CreateThread() 를 사용하여 새로운 쓰레드를 생성.
			작업이 끝나면 해당 쓰레드를 삭제해야 함.
			쓰레드 생성/삭제에는 오버헤드가 크므로 성능이 저하될 수 있음.

		(2)쓰레드 풀(Thread Pool) 방식
			작업이 필요할 때마다 새 쓰레드를 생성하지 않고, 미리 생성된 쓰레드를 재사용하여 작업을 할당함.
			작업이 끝난 쓰레드는 대기 상태(Idle)로 전환되어, 새로운 작업이 들어오면 다시 사용됨.
			불필요한 쓰레드 생성/삭제를 방지하여 성능을 최적화함. 
			즉, 쓰레드 풀은 "작업(Task) 기반"으로 쓰레드를 관리하여 성능을 향상시킨다! 

	3. 장단점
		(1)장점
			쓰레드 생성/삭제 비용 감소 → 성능 최적화
			CPU 코어를 최적화하여 효율적인 멀티쓰레딩 활용 가능
			작업(Task)을 균등하게 배분하여 부하를 줄임
			불필요한 컨텍스트 스위칭(Context Switching) 감소

		(2) 단점
			너무 많은 쓰레드를 사용하면 오히려 성능이 저하될 수 있음
			ex) CPU 코어 수보다 많은 쓰레드를 생성하면 오버헤드 증가
			작업(Task) 수가 많으면 큐가 과부하 상태가 될 수 있음
			일부 작업이 너무 오래 걸리면, 전체 시스템 성능이 저하될 수 있음 (스타베이션 문제)