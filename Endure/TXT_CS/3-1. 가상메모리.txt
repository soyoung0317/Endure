Q. 가상메모리에 대해 설명하시오.

Q. 스와핑에 대해 설명하시오 

Q. 페이지 테이블의 위치에 대해 설명하시오. 
-------------------------------------------------

 Q. 가상메모리에 대해 설명하시오
 A. 물리적 메모리보다 더 큰 메모리 공간을 사용할 수 있도록 하는 개념.
 
	1. 정의
		: 운영체제(OS)가 물리 메모리(RAM)의 용량보다 큰 메모리를 사용할 수 있도록 해 주는 기술
		: 프로그램이 사용하는 주소 공간(가상 주소)을 실제 물리 메모리 주소와 분리하여 관리함으로써, 
			효율적인 메모리 활용과 프로세스 간 메모리 보호를 가능하게 만든다.
		: 프로그램이 실행되는 동안 필요한 데이터의 일부만 실제 메인 메모리에 로드하고, 
			나머지 데이터는 디스크(보통 스왑 공간 또는 페이징 파일)에 저장하는 메모리 관리 기법입니다

		 [필요 기본 개념]
			+ 가상 주소(Virtual Address): 프로그램이 인식하는 메모리 주소로, 각 프로세스는 독립적인 가상 주소 공간을 가집니다.
			+ 물리 주소(Physical Address): 실제 메인 메모리(RAM)의 주소입니다.
			+ 페이지(Page): 가상 메모리를 고정된 크기의 블록으로 나눈 단위(일반적으로 4KB).
			+ 페이지 프레임(Page Frame): 물리 메모리를 같은 크기의 블록으로 나눈 단위.
			+ 페이지 테이블(Page Table): 가상 주소와 물리 주소 간의 매핑 정보를 저장하는 데이터 구조.
			+ 메모리 관리 유닛(MMU, Memory Management Unit): 가상 주소를 물리 주소로 변환하는 하드웨어 구성 요소.

	2. 특징
		: 각 프로세스는 독립된 주소공간을 갖고 메모리 크기의 제약으로부터 자유로워진다는 특징이 있습니다. 

		[Detail]
			- 메모리 용량 확장
			: 모든 프로그램을 실행하기에 실제 물리 메모리가 부족할 때, 가상 메모리를 사용해 일부 데이터를 디스크(하드디스크, SSD 등)에 임시로 보관한다. 
			이렇게 하면 프로그램은 실제 물리 메모리 크기보다 큰 주소 공간을 사용하는 것처럼 동작할 수 있습니다.
			
			- 메모리 보호와 독립성
			: 가상 메모리를 사용하면, 각 프로세스는 독립된 가상 주소 공간을 가집니다. 
			한 프로세스가 다른 프로세스의 메모리에 잘못 접근하는 문제가 줄어들고, 시스템 전반의 안정성이 높아집니다.
			
			- 프로그램 로딩 및 스와핑
			: 필요한 부분만 물리 메모리에 로드하고, 사용하지 않는 부분은 디스크로 내보내는(스왑) 방식으로 메모리를 효율적으로 쓸 수 있게 해 줍니다.

	3. 동작 방식
		: 가상 메모리의 동작 원리는 크게 페이징(Paging)과 세그멘테이션(Segmentation) 두 가지 방식으로 이루어집니다.
		페이징은 고정 크기의 블록으로 나누는 방식이며, 세그멘테이션은 서로 크기가 다른 논리적 단위인 세그먼트로 메모리를 나누는 방식입니다. 
		
		a. 페이징 으로 가상메모리 동작 원리 설명
			: 가상 메모리와 물리적 메모리를 페이지라는 작은 고정 크기의 블록으로 나누는 방식
			: 프로그램이 필요로 하는 메모리를 페이지 단위로 관리

			- 동작 과정은
			1) 페이지 테이블(Page Table) 설정
				* 가상 주소(Virtual Address): 프로세스가 인식하는 주소 공간
				* 물리 주소(Physical Address): 실제 RAM 상의 주소
				: 각 프로세스는 독립적인 페이지 테이블을 가집니다.
				: 페이지 테이블의 각 항목은 가상 페이지 번호와 물리 프레임 번호 간의 매핑 정보를 저장합니다.

			2) 주소 변환(Address Translation)
				: CPU가 가상 주소를 사용하여 메모리에 접근하려고 하는 경우, 메모리 관리 유닛(MMU)가 이 가상 주소를 받아 처리합니다.
					1] 가상 주소를 페이지 번호와 오프셋으로 분리
					2] 페이지 번호를 사용하여 페이지 테이블을 참조하고, 해당 페이지가 물리 메모리의 어느 프레임에 매핑되는지 확인합니다.
						2-1] TLB(Translation Lookaside Buffer)를 먼저 확인 
						2-2] TLB 히트: TLB에 매핑 정보가 있는 경우, 빠르게 물리 주소를 얻습니다.
							 TLB 미스: TLB에 매핑 정보가 없으면, 페이지 테이블을 참조하여 물리 주소를 얻고, 그 정보를 TLB에 캐싱합니다.
					3] 물리 프레임 번호와 오프셋을 결합하여 최종 물리 주소를 생성합니다.
						3-1] 페이지가 실제 물리메모리에 매핑되어있는지 확인하는 방법  
							페이지 테이블 엔트리(Page Table Entry, PTE) 안에 있는 ‘유효 비트(Valid/Present bit)’ 등을 통해 
							해당 가상 페이지가 실제 물리 메모리에 매핑되어 있는지를 확인합니다.
							
							1. 가상주소를 페이지번호, 오프셋으로 분리하고
							2. 해당 페이지 테이블에서 가상 페이지 번호에 해당하는 페이지 테이블 엔트리를 확인한다. 
							3. 페이지 테이블 엔트리에 있는 유효비트를 확인하는데, 1(true)면 물리메모리에 있으므로 해당 주소에 접근한다. 
								0(false)일경우 현재 물리메모리에 없거나 페이지 테이블에서 유효하지 않은 매핑이므로 페이지 폴트가 발생한다. 
			
		b. 세그멘테이션
			: 가상 메모리를 논리적으로 크기가 다른 세그먼트(Segment)로 나누는 방식입니다
			
			- 동작 과정은
			1) 세그먼트 테이블(Page Table) 설정
				세그먼트 번호(Segment Number): 상위 비트로, 어떤 세그먼트에 접근할지를 나타냅니다.
				오프셋(Offset): 하위 비트로, 세그먼트 내에서의 정확한 위치를 지정합니다.
				가상 주소 = [세그먼트 번호] + [오프셋]
			
			2) 주소 변환(Address Translation)
			: CPU가 가상 주소를 사용하여 메모리에 접근하려고 하는 경우, 메모리 관리 유닛(MMU)가 이 가상 주소를 받아 처리합니다.
				예를 들어, 가상 주소 S:O (세그먼트 번호 S, 오프셋 O)에 접근하려고 할 때입니다.
			
				2-1] 세그먼트 번호를 사용하여 세그먼트 테이블에서 해당 세그먼트의 기본 주소와 한계를 조회합니다.
				2-2] 한계는 해당 세그먼트의 크기를 나타내며, 오프셋이 한계 내에 있는지 확인합니다. 
				2-3] 만약 오프셋이 한계를 초과하면 세그먼트 오류(Segment Fault)가 발생합니다.

			3) 물리 주소 생성:
			: 기본 주소에 오프셋을 더하여 최종 물리 주소를 생성합니다.


	4. 장점
		- 메모리 효율적 사용: 필요할 때만 물리 메모리를 할당하고, 사용하지 않는 메모리는 디스크에 두어 전체적으로 메모리를 더 잘 활용할 수 있습니다.
		- 프로그램 크기 제한 완화: 물리 메모리가 작아도, 큰 프로그램을 부분적으로 로드하며 실행할 수 있습니다.
		- 메모리 보호: 프로세스마다 독립적인 주소 공간을 가지므로, 잘못된 포인터 연산이나 오류가 다른 프로세스의 메모리를 침범하는 일을 막을 수 있습니다.

	5. 단점
		- 속도 저하: 디스크 I/O는 RAM보다 훨씬 느리므로, 스왑(디스크로부터/로의 페이지 이동)이 자주 발생하면 시스템 성능이 크게 떨어질 수 있습니다.
		- 페이지 폴트 오버헤드 : 페이지 폴트가 자주 발생하면 디스크 I/O가 빈번해져 성능 저하가 발생할 수 있습니다(스래싱(Thrashing) 현상).
		- 디스크 공간 사용: 실제 물리 메모리가 부족할 경우 스왑 공간이 필요하고, 이로 인해 디스크 사용량이 늘어날 수 있습니다.
		- 스왑 공간: 디스크에 스왑 영역(Swap Space)을 마련해야 하며, 이 영역의 크기나 디스크 성능도 시스템 퍼포먼스에 영향을 줍니다.
		
-------------------------------------------------

Q. 스와핑에 대해 설명하시오 
A. 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역(스왑영역)으로 쫒아내고 빈 공간에 새 프로세스를 적재하는것을 의미합니다. 

	장점 : 실제 메모리 크기 보다 큰 프로세스들을 사용할 수 있다. 
	
-------------------------------------------------

Q.	페이지 테이블의 위치에 대해 설명하시오. 
A.	일반적으로 페이지 테이블은 메인 메모리에 위치합니다. 

	그러나 페이지 테이블에 대한 접근 속도를 높이기 위해 TLB(Translation Lookaside Buffer)라는 고속 캐시 메모리를 사용하여 
	자주 참조되는 페이지 테이블 엔트리를 캐싱합니다.

	1. 메인 메모리 내 위치:
		각 프로세스마다 별도의 페이지 테이블이 존재하며, 이들은 메인 메모리 내에 할당된 특정 영역에 저장됩니다.
		페이지 테이블은 운영체제에 의해 관리되며, 페이지 폴트 발생 시 운영체제가 페이지 테이블을 업데이트합니다.
	
	2. TLB (Translation Lookaside Buffer): 
		TLB는 CPU 내부 또는 가까운 위치에 위치한 고속 캐시로, 페이지 테이블의 일부 엔트리를 저장합니다.
		주소 변환 시 먼저 TLB를 참조하여 매핑 정보를 찾고, 없을 경우 메인 메모리의 페이지 테이블을 참조합니다.
		TLB 히트율이 높을수록 주소 변환 속도가 빨라져 전체 시스템 성능이 향상됩니다.

-------------------------------------------------