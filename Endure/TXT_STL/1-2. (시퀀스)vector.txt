Q. vector에 대해 설명하시오

Q. vector<bool>의 구현방식에 대해 설명하시오.

Q. emplace_back과 push_back의 객체 생성 최적화 에 대해 설명하시오.

Q. vector의 재할당시 메모리 크기를 얼마로 할당하는가?

Q. vector의 resize, reserve, capacity에 대해 설명하시오

Q. 원소가 가득찬 벡터의 0번 인덱스로 새로운 값을 insert 할 때와 push_back으로 새로운 값을 추가할 때를 설명하시오.  

-------------------------------------------------
Q.	vector에 대해 설명하시오
A.	C++ 표준 탬플릿 라이브러리의 핵심 컨테이너중 하나로, 동적배열을 구현한 자료구조이다. 런타임동안 크기를 유연하게 조절할 수 있는 특성이 있어 매우 자주쓰인다. 


	1. 정의
		template < class T, class Allocator = std::allocator<T> >
		class vector;

	2. 주요 특징
		- 요소들이 연속된 메모리공간에 저장되어 인덱스를 통한 빠른 접근이 가능하다.
		- 자동으로 메모리 관리가 이루어진다. (push_back 사용시 자동확장)
		- 템플릿 기반으로 어떤 타입이든 저장이 가능하다. (vector<MyClass> 등)

		- 인덱스를 통한 접근 : O(1)
		- 중간 삽입 삭제 : O(n)
		- 마지막요소 삽입 삭제 : O(1)

	3. 주요 멤버 함수
		1) 생성자
			std::vector<int> v1;                   // 빈 벡터
			std::vector<int> v2(10);               // 10개의 기본값 0으로 초기화
			std::vector<int> v3(10, 5);            // 10개의 5로 초기화
			std::vector<int> v4 = {1, 2, 3};       // 초기화 리스트 사용
		2) 크기 관련
			size() : 현재 요소 수 반환
			capacity() : 실제 할당된 메모리 공간 수
			resize(n) : 요소 수를 n으로 조정
			reserve(n) : 최소한 n개의 요소를 담을 수 있도록 메모리 확보
			shrink_to_fit : 할당된 메모리 공간의 수를 제거한다. 

		3) 삽입 및 삭제
			push_back(value) : 끝에 요소 추가
			pop_back() : 마지막 요소 제거
			insert(pos, value) : 특정 위치에 삽입
			erase(pos) : 특정 위치의 요소 제거
			clear() : 모든 요소 제거

		4) 접근
			operator[], at(i) : 인덱스로 접근
			front(), back() : 처음/마지막 요소 반환
			data() : 내부 배열 포인터 반환

	4. 내부 동작 방식 ( 메모리 재할당 포함 )
		내부적으로 버퍼(배열)을 관리한다. 
		동적 크기조절을 위해 capacity가 초과되었을 때 자동으로 메모리를 재할당하며, 보통 기존 용량의 2배 크기로 증가시킨다. 
		기존용량의 2배 크기로 새로운 메모리 블록 할당 -> 기존요소 복사 또는 이동 -> 이전메모리 해제 

	5. 복사 vs 이동
		벡터는 이동시멘틱을 적극적으로 활용하는 stl이다. 
		벡터가 리턴되거나 다른 벡터에 대입될때 이동생성자 또는 이동대입연산자가 호출되어 불필요한 복사를 방지한다. 

		1) 복사비용
			깊은복사를 기본으로 하며, 이동생성자를 통해 복사비용을 줄이기도한다. 

	6. 주의사항
		1) 반복적인 push_back 사용시 재할당이 발생 -> 성능저하
			: reserve로 미리 용량 확보하기
		2) 중간삽입 삭제가 빈번할경우 list가 더 유리할수있음
		3) vector<bool>은 특수화된 구조 -> 비트단위로 사용에 주의가 필요하다. 
		4) 인덱스 접근 vs 내부함수 at을 통한 접근
			: 인덱스를 통한 접근시 잘못된 인덱스 접근 (vector<int> a = {1, 2} ; int b = a[3];)시 컴파일오류없이 실행되지만 잘못된 메모리에 접근하므로 예측불가능한 동작이 이루어진다.
			a.at[i] 처럼 내부함수를 통한 접근의 경우 범위검사가 이루어져 std::out_of_range라는 예외를 던져 try-catch로 처리할 수 있다. 

 	7. 사용예시	
	: 툴에서 파싱한 데이터를 읽어올 때 사용하였습니다. 
	데이터를 읽으면서 레이어 단위로 벡터에 넣고, 레이어 안에 있는 오브젝트를 순회하면서 클론을 통해 오브젝트를 생성하는 방식으로 구현하였습니다. 
	
-------------------------------------------------

Q. vector<bool>의 구현방식에 대해 설명하시오.
A.
	일반적인 vector<T> 와 다르게 bool값 하나당 1바이트가 아니라 1비트만 차지하도록 특수하게 최적화된 템플릿 특수화 버전이다. 

	vector<bool> v = {true, false, false};

	위 코드에서 v는 내부적으로 bool을 3개 사용하는데, 3바이트가 아니라 3비트만 사용해서 저장한다. 
	메모리 절약에는 좋지만 직접적인 포인터 접근이나 참조변환이 어려워져 일반 vector<int>와 다르게 동작한다. 

	따라서, bool* p = &v[0]; 
	불가능하다. (컴파일 에러 발생)
	내부에 저장된값이 bool 1바이트 데이터타입이 아니라 비트 단위의 프록시 객체로 래핑되어있어서 일반 포인터처럼 사용할 수 없다. 
	v[0]의 타입이 bool& 타입이 아니라 std::_Bit_reference이다. 
	-> vector<char>나 vector<uint8_t> 로 대체하기도한다. 

-------------------------------------------------

Q. emplace_back과 push_back의 객체 생성 최적화 에 대해 설명하시오.
A.	
	1. push_back
		객체를 먼저 생성하고 컨테이너에 삽입하는 방식
		객체가 없이 삽입을 하려면 "임시객체 (rvalue) " 가 있어야 합니다.

		1). push_back을 통해 객체를 삽입하기 위해, item 임시 객체를 하나 만듭니다.
		2). 임시 객체를 복사 생성자를 통해 push_back 함수 내에서 임시 객체를 만들어 냅니다.
		3). 함수내에 만들어진 임시 객체를 vector 의 끝에 추가합니다.
		4). 함수를 빠져나온 후, push_back에 삽입하기 위해 만들었던 (1번) item 임시 객체를 소멸시킵니다.

		= push_back 호출 > 일반 생성자 호출 > 이동 생성자 호출 > 소멸자 호출 

	2. emplace_back
		가변인자 템플릿을 사용하여 객체 생성에 필요한 인자만 받은 후 함수 내에서 객체를 생성해 삽입하는 방식입니다.

		1). v.emplace_back(3);
		2). emplace_back 내부에서 임시객체를 만들어냄
		3). vector 에 객체 삽입
		4). main 이 끝난 후 vector에 삽입된 객체 소멸
		= emplace_back 호출 > 일반 생성자 호출 > 소멸자 호출 

	이렇게 객체의 생성과 삽입을 하나의 호출로 처리하므로 코드가 더 간결해지고 객체의 삽입과정에서 불필요한 복사가 일어나지 않도록 피할 수 있습니다. 


	3. 언제 유용한가?
		: 복사 비용이 큰 클래스일때, (string, 사용자 정의타입, 등)
		: vector<GameObject> 와 같이 많은 객체를 생성하고 관리하는 상황에서 사용 


-------------------------------------------------

Q.	vector의 재할당시 메모리 크기를 얼마로 할당하는가?
A.	기존용량의 두배로 증가시킵니다. 
	이경우 다중 재할당을 방지하기 위해서 입니다. 

-------------------------------------------------

Q.	vector의 resize, reserve, capacity에 대해 설명하시오
A.	capacity : 할당해놓은 배열의 크기 
	size : 배열에 저장된 원소의 개수 
	resize : 벡터의 size를 조정하는 함수로 메모리를 새롭게 할당 + 초기화 
	reserve : 벡터의 capacity를 조정하는 함수로 메모리를 새롭게 할당 / 현재 capa보다 커야지만 동작한다. / 어떤한 값으로 초기화 하지 않는다. 

	resize가 capa보다 큰경우 용량은 여전히 5일 수 있다. 
[예시]	vector<int> vec = {1, 2, 3};
		vec.resize(5); // {1, 2, 3, 0, 0}

-------------------------------------------------

Q.	원소가 가득찬 벡터의 0번 인덱스로 새로운 값을 insert 할 때와 push_back으로 새로운 값을 추가할 때를 설명하시오.  
A.	0번 인덱스에 새로운 값을 추가 할 때, 
	2배의 용량으로 벡터를 하나 만들고, 0번 인덱스에 새로운 값을 추가한뒤, 이후 기존의 값들을 이동시킨다. 
	기존 벡터역시 자동으로 메모리가 해제됩니다. 

-------------------------------------------------