Q. 단방향 리스트(forward list)에 대해 설명하시오 

Q. list와 forward list의 차이에 대해 설명하시오 

-------------------------------------------------------

Q. forward list에 대해 설명하시오 
A.
	1. 정의
		단일 연결 리스트(Singly Linked List) 컨테이너로, 각 노드가 다음 노드에 대한 포인터만 가지고 있어 한 방향으로만 순회할 수 있습니다.

	2. 특징 및 주의사항 (장단점 포함)
		(1) 장점
			메모리 사용이 효율적: 노드당 포인터가 하나뿐이라 list보다 공간 절약
			앞쪽 삽입/삭제가 매우 빠름 (O(1))
			삽입/삭제 시 요소 이동이나 재할당이 없어서 안정적
			
		(2) 단점 및 주의사항
			임의 접근 불가능 (인덱스 접근 안됨)
			뒤쪽 노드로 거슬러 올라갈 수 없어, 양방향 탐색 불가
			중간 삽입/삭제는 insert_after, erase_after를 사용해야 함
			순회는 반드시 앞에서부터 한 방향으로만 가능
			다른 컨테이너에 비해 탐색 속도가 느림 (O(n))

	3. 동작방식
		노드들은 단방향으로 연결되어 있으며, begin()은 리스트의 첫 노드를 가리킴
		push_front로 앞에 새 노드 추가, pop_front로 앞 노드 삭제
		중간 위치 조작은 해당 노드 바로 뒤에 삽입/삭제하는 insert_after, erase_after 사용
		단방향 반복자를 이용해 앞에서 뒤로 순차 접근만 가능

	4. 복사와 이동
		복사 생성자와 복사 대입 연산자는 리스트의 모든 노드를 복사해 새로운 리스트 생성
		이동 생성자와 이동 대입 연산자는 내부 포인터를 옮겨서 복사보다 빠른 연산 제공
		복사 시에는 노드 하나하나 새로 할당하므로 비용이 크지만,
		이동 시에는 포인터만 옮기므로 비용이 적음

	5. 주요 멤버 함수
		push_front(const T&) / push_front(T&&) : 리스트 앞에 요소 삽입
		pop_front() : 리스트 앞 요소 삭제
		insert_after(iterator pos, const T&) : pos 다음에 요소 삽입
		erase_after(iterator pos) : pos 다음 요소 삭제
		before_begin() : 첫 요소 바로 앞 위치 반환 (특수 iterator)
		begin(), end() : 리스트의 첫 요소와 끝(마지막 다음) 위치 반복자 반환
		empty(), size() : 비어있는지 확인, (size는 C++20부터 지원)
		clear() : 모든 요소 삭제
		assign() : 리스트에 새로운 값 할당
		remove(const T&) : 특정 값 가진 모든 요소 삭제
		sort() : 리스트 정렬 (비교 연산자 필요)
		reverse() : 리스트 순서 뒤집기
		merge() : 두 리스트를 정렬 상태에서 합치기
		
-------------------------------------------------------
		
Q. list와 forward list의 차이에 대해 설명하시오 
A.
	1. 정의
		list: 이중 연결 리스트(doubly linked list) 구조를 가지는 컨테이너입니다. 
			각 노드는 이전 노드와 다음 노드를 가리키는 포인터를 가지고 있어서 양방향 탐색이 가능합니다.
		forward_list: 단일 연결 리스트(singly linked list) 구조를 가지는 컨테이너입니다. 
			각 노드는 다음 노드만 가리키는 포인터를 가지고 있어 단방향 탐색만 가능합니다.
		
	2. 왜 사용하는가
		list: 양방향 탐색이 필요하고, 노드의 삽입과 삭제가 리스트 어느 위치에서든 빈번하게 일어날 때 사용합니다.
			list는 이중 연결 리스트의 특성 덕분에 뒤로 이동하며 작업해야 하는 경우(예: 역방향 탐색, 양방향 순회)에 유리합니다.
		forward_list: 메모리 사용을 줄이고, 단방향 탐색만으로 충분한 경우 사용합니다. list보다 구조가 간단하고, 메모리 오버헤드가 적습니다.
			forward_list는 양방향 탐색이 필요하지 않고 메모리를 아껴야 할 때 적합합니다.