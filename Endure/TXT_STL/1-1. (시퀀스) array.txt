Q. array에 대해 설명하시오 

Q. array의 복사와 이동에 대해 설명하시오. 

Q. 왜 array의 이동만 비효율적인가?

-------------------------------------------------

Q. array에 대해 설명하시오 
A.	
	1. 정의
		C++11에서 도입된 고정 크기 배열을 래핑한 컨테이너 클래스입니다.
		기존의 C 스타일 배열보다 안전하고 STL 친화적인 인터페이스를 제공합니다.

	2. 주요 특징
		- 고정 크기 : 컴파일 타임에 크기가 정해짐
		- STL 호환 : 반복자, 범위 기반 for문, 알고리즘 사용 가능
		- 배열과 비슷한 성능 : 메모리는 연속적 (contiguous)
		- 안전한 접근 : .at() 사용 시 범위 검사 가능 (예외 발생)
		- 동적할당을 피함 : vector는 heap에 할당하지만 array는 stack에 할당한다. 

	3. 주요 멤버 함수 - C스타일은 함수호출불가능 / C++은 함수호출 가능
		.size() : 배열의 크기 반환
		.at(index) : 인덱스 접근 (범위 검사 포함)
		.front() : 첫 번째 요소
		.back() : 마지막 요소
		.begin(), .end() : 반복자 반환 (for-each 사용 가능)
		.fill(value) : 모든 요소를 해당 값으로 채움

	4. 내부 동작방식 -메모리 구조
		: std::array<T, N>는 내부적으로 크기가 N인 T 타입의 정적 배열을 멤버로 가집니다.
		: 배열의 메모리는 객체 자체에 포함되어 있고, 포인터가 아님.
		이로 인해 성능이 높고, **캐시 친화적(cache-friendly)**입니다.

	5. 복사와 이동
		: 이동(move)가 되긴하지만, 내부 동작은 복사와 거의 동일하여 이동최적화가 되지 않는 컨테이너이다.
			array<int> a = {0, 1, 2, 3, 4, 5}
			array b = std::move(a); 
		: 내부적으로 array 자체가 아니라 원소마다 move를 호출하게된다. 
		이떄 각 원소의 move 생성자 / move 대입연산자가 호출될뿐, 원소 하나하나를 개별 이동시키다보니 깊은복사가 이루어져 결국 이동이나 복사나 값이 비슷하다. 

	6. 주의사항
		- 크기 변경 불가 : std::array는 컴파일 타임 고정 크기라서 .resize() 같은 함수가 없습니다.
		- 초기화 필수 : {}로 초기화 안 하면 쓰레기 값이 들어갈 수 있음 (특히 POD 타입)
		- 빈 array 불가 : std::array<T, 0>은 유효하지만, 대부분의 STL 알고리즘에서 오류 가능성 있음
		- 얕은 복사 주의 : 배열 안에 포인터가 있을 경우, 복사 시 깊은 복사 필요 여부를 판단해야 함

	7. 주요 정리
		- std::array는 STL 친화적인 정적 배열입니다.
		- 고정 크기, 빠른 성능, 메모리 절약이 필요한 경우 유리합니다.
		- 다만 크기 변경이 필요한 경우엔 std::vector가 더 적합합니다.
-------------------------------------------------

Q. array의 복사와 이동에 대해 설명하시오. 
A.
	array는 정적배열이다. 즉 배열의 크기가 컴파일타임에 고정되고, 메모리공간도 배열의 크기에 맞춰서 이미 할당중이다. 
	배열의 크기가 고정되어있기때문에 배열자체를 이동할 수 없다. 
	
	array<string, 5> arr1 = { "a", "b", "c", "d", "e", };
	array<string, 5> arr2 = std::move(arr1);
	-> 주의. int와 같은 원시타입은 이동생성자가 없어서 그냥 복사된거. 이동생성자가 있는 데이터타입으로 비교하기

	1. 배열자체의 이동
		배열을 이동하려면, 배열 자체의 메모리 공간을 다른 곳으로 이동시켜야 하는데, 
		정적 배열은 이미 메모리에서 고정된 주소에 할당되었기 때문에 그 메모리를 이동할 수 없습니다.
	2. 배열 내부 원소의 이동
		std::array는 배열 크기를 정적으로 고정하므로, 그 크기가 변하지 않습니다.
	3. 배열 자체의 소유권 이동 불가
		정적 배열은 메모리 상에서 고정된 크기와 주소를 가지기 때문에, 
		소유권을 이동시키면 배열의 크기가 변하거나 메모리 주소가 변경되어야 하는데, 정적 배열에서는 그게 불가능합니다.
		
	여기서, move(arr1)을 하더라도 실제로 배열 arr1이 이동하는게 아니라 배열의 원소들이 하나씩 move가 이루어진다. 
	원소 개별적으로 본다면 이동이 맞다. 소유권을 넘긴다. (move 생성자가 호출됨)
	그런데 배열전체 array의 관점에서 보면, 배열 자체의 메모리를 옮길수는 없어서 이동해도 마치 복사처럼 동작한다. 
	내부적으로는 아래처럼 이동한다.

	arr2[0] = std::move(arr1[0]); // move 생성자 호출됨
	arr2[1] = std::move(arr1[1]); // move 생성자 호출됨
	arr2[2] = std::move(arr1[2]); // move 생성자 호출됨

	깊은복사 ? 얕은복사 ?
	: int, float, bool등은 -> 얕은 복사
	: std::string, std vector 등 사용자 정의 객체 -> 깊은 복사
	: 포인터 -> 얕은 복사 

	“원소는 이동하지만, 배열은 이동 못하니 결과가 복사처럼 느껴진다”


-------------------------------------------------

Q. 왜 array의 이동만 비효율적인가?
A.
	다른 STL 컨테이너의 경우 자신들의 내용물을 힙에다 저장해둔다. 
	그래서 move 연산을하면 저장공간의 주소만 swap하여 빠르게 동작할 수 있다. 

	 std::array의 경우 그러한 힙 영역에 대한 포인터가 없다! 왜냐하면 std::array의 원소들은 std::array 객체 자체에 저장되기 때문이다. 
	 그렇다면 std::array의 move 동작은 저장된 원소들 하나하나를 move하는 작업이 필요하다.

